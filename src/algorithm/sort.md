<TitleList></TitleList>

# 排序算法

### 冒泡排序
将相邻的两个元素进行比较，顺序相反则进行位置交换，直到将最大，或最小的元素推到最顶端。每一轮比较都从头开始，并且每次的步长加1。  

复杂度为 O(n²)   
空间复杂度为 O(1)   

### 选择排序
每一趟从待排序的数据元素中选择最小（或最大）的一个元素与当前元素进行位置交换，然后步长加1，直到所有元素排完为止。  

时间复杂度为 O(n²)   
空间复杂度为 O(1)  

### 插入排序
将每一个元素插入到前面排好序的序列中去，具体操作是，将当前元素n与前面 [n-1,n-2 ... n-0] 的元素比较，如果小于（或大于）则将 [n-1,n-2 ... n-0] 的元素位置往后挪一位，直到有合适的空出位置，存入元素n  

时间复杂度为 O(n²)  
空间复杂度为 O(1)  

### 希尔排序
<Te d>插入排序</Te>的一种优化排序，使插入排序更加高效。  

具体操作是：  
- 假设数组长度为10
- 按照数组的长度进行分组，比如每两个元素为1组，可以分为5组，进行插入排序
- 排序之后，又对数组进行**增量分组**，比如分组数量减半，则可以5/2，将数组分为2组，因为之前已经有部分排好序了，所以重新分的两组序列已经有部分元素排好序了，不需要再交换位置，进行插入排序，速度比较快。
- 直到将增量分组为1，即不再分组，直接对数组进行操作，此时很多元素已经排好序了，只有少量的元素需要换位置，所以进行插入排序的效率又更高了。

总之，希尔排序的目的就是尽量减少插入排序时，需要滚动已排好序的数组的次数。  

时间复杂度为 O(nlogN)   
空间复杂度为 O(1)  