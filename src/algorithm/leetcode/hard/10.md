# 寻找重复数
[题目](https://leetcode.cn/leetbook/read/top-interview-questions-hard/xwz4lj/)  

###### 解题思路一，暴力双循环
- 时间复杂度 O(n2)
- 空间复杂度 O(1)

###### 解题思路二，二分法
- 计算 n 的中值 const mid = Math.ceil(n/2)
  - 如果 start === end 返回 start，并结束循环
  - n 为 奇数
    - 遍历 数组，统计 大于 mid 的元素数量 rightCount、小于 mid 的元素数量, leftCount 和 等于 mid 的元素 midCount.
    - 如果 midCount 大于 1，则该mid元素是重复的
    - 如果 lefCount >= mid 则 重复的数在左边。继续二分 (star + mid)/2
    - 如果 rightCount >= mid 则 重复的数在右边。继续二分 (mid + end)/2
  - n 为 偶数
    - 遍历 数组，统计 大于 mid 的元素数量 rightCount、小于等于 mid 的元素数量, leftCount.
    - 判断 lefCount > mid 还是 rightCount > mid，然后继续二分遍历
- 时间复杂度 O(n log n)
- 空间复杂度 O(1)

###### 解题思路三，快慢指针
[环形链表II的方法解题](https://leetcode.cn/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/) 解决本题   
[环形链表II的方法解题](https://leetcode.cn/problems/find-the-duplicate-number/solution/kuai-man-zhi-zhen-de-jie-shi-cong-damien_undoxie-d/)  解决本题 

同时同位置出发  
- 慢指针，在环形链中走一步是 slow.next，在数组中走一步 是 nums[slow]
- 快指针，在环形链中走两步是 fast.next.next，在数组中走两步 是 nums[nums[fast]]
  - 先假设一些量
    - slow 和 fast 在环中相遇，slow 走一步，fast 走两步，那么 fast 走的距离是slow 的2倍
    - 假设起点到环的距离是m，环的周长是c。
    - 那么当 slow 走了 m+c 时，则 fast 走了 2(m + c),但是 fast 的其中一个m是在环上走的。

```js
var findDuplicate = function(nums) {
    let slow = 0;
    let fast = 0;
    slow = nums[slow];  // 慢指针先走一步
    fast = nums[nums[fast]]; // 快指针先走两步
    while(slow != fast){ // 如果存在环，则 快慢指针会在某一个节点相遇
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    
    let pre1 = 0; // 这个时候，将其中一个指针 从新放到开头
    let pre2 = slow; // 另外一个指针还是会不断的重新循环，pre1 也会进入循环，然后判断两个值相同的时候，就是重复值。
    while(pre1 != pre2){
        pre1 = nums[pre1];
        pre2 = nums[pre2];
    }
    return pre1;
};
```